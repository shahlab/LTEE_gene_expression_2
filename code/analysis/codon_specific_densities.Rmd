---
title: "Codon specific densities"
output: 
  html_document:
    df_print: paged
author: "John Favate"
date: "`r Sys.time()`"
---

```{r}
# Prevent printing of warnings and such in the HTML
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
```

```{r}
library(tidyverse)
library(Biostrings)
library(GenomicAlignments)
library(parallel)
library(feather)

# get a vector for only e coli protein coding genes, not insertional elements or tRNAs or ERCCs
ecbs <- read_csv("../../data_frames/all_data.csv") %>% # read in the combined data frame
  filter(gene_type == "ECB") %>%                       # these are the protein coding genes
  pull(target_id) %>%                                  # get them as a vector
  unique()
```

This document details the calculation of codon specific densities. These numbers are derived from BAM files generated by hisat2 as opposed to the kallisto counts. This code generates large files in RAM, upwards of 3Gb, and also attempts to use multithreading, you might need to change some of these values to run properly on your system.

### Get all the relevant files

The riboseq bams locations.
```{r}
bam.locs <- dir("../../alignment/hisat2/output", pattern = ".bam", full.names = TRUE)

names(bam.locs) <- str_extract(bam.locs, "rep[12]-[a-z]{3,4}-(?i)[a-z]{3,4}[0-9]{1,2}")

only.riboseq.bams <- bam.locs[grepl("ribo", names(bam.locs)) & !(grepl("AraP6", names(bam.locs)))]
```

The fastas, note the pattern, which differentiates it from the rRNA fasta.
```{r}
fa.locs <- dir("../../fastas", full.names = TRUE, pattern = ".fasta")

names(fa.locs) <- str_extract(fa.locs, "Ara[RMP][1-7]")

fasta.list <- lapply(fa.locs, readDNAStringSet)
```

Find all the insertional elements.
```{r}
bdf <- read_csv("../../data_frames/biocyc_df.csv")

# list all the insertional elements
bdf %>%
  filter(grepl("ins", rel_name)) %>%
  pull(rel_name) %>%
  unique()

# get their target_ids
ins.elements <- bdf %>%
  filter(grepl("ins", rel_name)) %>%
  pull(target_id)
```

### Assign reads to codons

The bams. While reading in the bams, we also add a column for the A-site of the riboosome by adding a fixed offset, in this case 37 (25 + 12), to the end of the read. 

This reads in the BAM files, adds the offset of 37 (25 + 12) and assigns each read to a codon, eventually summing up the number of reads that occur at each codon for each gene in each sample.
```{r}
bam.list <- mclapply(only.riboseq.bams, function(x){
  # get only primary reads
  flag <-
    scanBamFlag(
      isUnmappedQuery = FALSE,
      isSecondaryAlignment = FALSE,
      isSupplementaryAlignment = FALSE
    )
  
  # make the param object
  p <- ScanBamParam(flag = flag)
  
  readGAlignments(x, param = p) %>%                                                    # read in each bam file
    as_tibble() %>%                                                                    # turn it into a tibble
    mutate(a_site = as.integer(end - 37),                                              # add the position of the A-site for each read
           seqnames = as.character(seqnames)) %>%                                      # change seqnames from factor to character
    filter(grepl("ECB", seqnames) & !(seqnames %in% ins.elements) & strand == "+") %>% # e coli protein genes only, + strand only
    dplyr::select(seqnames, a_site) %>%                                                # only need these columns going forward
    mutate(codon_position = as.integer(floor(a_site/3))) %>%                           # figure out which codon the A-site was at
    group_by(seqnames, codon_position) %>%                                             # for each codon in each gene
    tally() %>%                                                                        # sum number of reads mapping to said codon
    ungroup() %>%
    filter(codon_position >= 0)                                                        # only take the start codon and further down
}, mc.cores = 28)
```

Combine all of those into one data frame.
```{r}
bam.df <- bam.list %>%
  bind_rows(.id = "sample") %>%
  separate(sample, into = c("replicate", "seqtype", "line")) %>% 
  dplyr::select(-seqtype)

head(bam.df)
```

### Identifying each codon in a gene

We know codon positions in the above table, but we don't know what that codon is. This code takes the fastas from each of the line and determines what codon each position is. We'd also like to know the amino acid.
```{r}
test <- fasta.list[[1]][100:101]

split_seqs_to_codons <- function(x){
  # reduce the fasta to only the cds and pick only e coli protein coding genes
  fasta <- x %>%
    subseq(start = 26, end = width(.) - 25) %>%
    .[names(.) %in% ecbs]
  
  # sequence splitting part
  sapply(as.character(fasta), function(y){           # for each sequence
    str_extract_all(y, "[ATCG]{3}")                  # split into codons
  }) %>% 
    enframe(name = "seqnames", value = "codon") %>%  # get them in a data frame
    unnest(cols = c(codon)) %>% 
    group_by(seqnames) %>%                           # in a gene specific manner
    mutate(codon_position = row_number()-1) %>%      # get position of the codon, use 0 indexing
    ungroup() %>% 
    mutate(amino_acid = as.character(translate(DNAStringSet(codon), no.init.codon = TRUE))) # get the amino acid
      
}
```

Check to see that it works on 2 genes, this finds number of codons (n) and number of bases it should have come from, i.e. gene length (nn).
```{r}
split_seqs_to_codons(test) %>% 
  group_by(seqnames) %>% 
  tally() %>% 
  mutate(nn = n*3)
```

It does.
```{r}
subseq(test, start = 26, end = (width(test) - 25))
```

Apply that function to get a list of data frames, bind them together.
```{r}
split.fastas.list <- mclapply(fasta.list, split_seqs_to_codons, mc.cores = length(fasta.list))

all.genes.all.codons1 <- split.fastas.list %>%
  bind_rows(.id = "line") %>%
  mutate(replicate = "rep1")

# need a second, identical data frame but for rep2
all.genes.all.codons2 <- split.fastas.list %>%
  bind_rows(.id = "line") %>%
  mutate(replicate = "rep2")

all.genes.all.codons <- bind_rows(all.genes.all.codons1, all.genes.all.codons2)

head(all.genes.all.codons)
```

### join codons to read data

Relate codon positions in `bam.df` to actual codons in `all.genes.all.codons`. Then calculate a bunch of codon density information. This is codon density information with the highest number of dimensions, i.e. all lines, replicates, genes, codons. 
```{r}
codon.density.per.gene.df <- left_join(all.genes.all.codons, bam.df, by = c("line", "seqnames", "codon_position", "replicate")) %>%
  group_by(line, seqnames, replicate) %>%                               # group by these
  mutate(n_with_zero = ifelse(is.na(n), 0, n),                          # new n column where NAs are 0
         gene_mean_n = mean(n, na.rm = TRUE),                           # get gene specific mean
         gene_mean_n_with_zeros = mean(n_with_zero),                    # again with 0's for NAs
         normalized_n = n/gene_mean_n,                                  # normalize reads to gene
         normalized_n_with_zeros = n_with_zero/gene_mean_n_with_zeros,  # same for 0's instead of NAs
         sum_counts = sum(n, na.rm = TRUE)) %>%                         # reads per gene
  ungroup()

# some renaming
codon.density.per.gene.df <- codon.density.per.gene.df %>%
  dplyr::rename(target_id = seqnames,
                n_reads_sans_zero = n,
                n_reads_with_zero = n_with_zero,
                mean_reads_per_gene_sans_zero = gene_mean_n,
                mean_reads_per_gene_with_zero = gene_mean_n_with_zeros,
                normalized_reads_per_gene_sans_zero = normalized_n,
                normalized_reads_per_gene_with_zero = normalized_n_with_zeros,
                reads_per_gene = sum_counts)

codon.density.per.gene.df$line <- gsub("AraM", "Ara-", codon.density.per.gene.df$line) %>%
  gsub("AraP", "Ara+", .) %>%
  gsub("AraR", "REL60", .)

# this is saved as a feather file because it's large
write_feather(codon.density.per.gene.df, "../../data_frames/codon_density_per_gene.feather")

head(codon.density.per.gene.df)
```

Get genome wide codon density, only for genes with > 100 reads.
```{r}
genome.wide.codon.density <- codon.density.per.gene.df %>%
  filter(reads_per_gene >= 100) %>%
  group_by(codon, line, replicate, amino_acid) %>%
  summarise(avg_ribo_n = mean(normalized_reads_per_gene_sans_zero, na.rm = TRUE),
            avg_ribo_n_w_0 = mean(normalized_reads_per_gene_with_zero)) %>%
  ungroup()

write_csv(genome.wide.codon.density, "../../data_frames/table_s8_genome_wide_codon_densities.csv")

head(genome.wide.codon.density)
```

```{r}
sessionInfo()
```